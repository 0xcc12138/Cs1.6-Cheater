#include "周围对象.h"
#include "pch.h"
#include <iostream>



void 周围对象::获取自身坐标和朝向()
{
	//首先拿一下hw.dll的基地址
	
	this->自身坐标和朝向.玩家的x坐标 = *(float*)(cstrike基地址 + 0x19E3F28);
	this->自身坐标和朝向.玩家的y坐标 = *(float*)(cstrike基地址 + 0x19E3F2C);
	this->自身坐标和朝向.玩家的z坐标 = *(float*)(cstrike基地址 + 0x19E3F30);

	this->自身坐标和朝向.玩家的朝向结构.垂直朝向 = *(float*)(cstrike基地址 + 0x19E10C4);
	this->自身坐标和朝向.玩家的朝向结构.水平朝向 = *(float*)(cstrike基地址 + 0x19E10C8);
}

void 周围对象::计算朝向(对象结构& 对象)
{
	this->获取自身坐标和朝向();
	if (对象.对象重心的x坐标 > this->自身坐标和朝向.玩家的x坐标 && 对象.对象重心的y坐标 > this->自身坐标和朝向.玩家的y坐标)
	{
		//说明这是在第一象限
		//开始计算角度
		对象.对象的重心朝向.水平朝向 = atan2(对象.对象重心的y坐标 - this->自身坐标和朝向.玩家的y坐标, 对象.对象重心的x坐标 - this->自身坐标和朝向.玩家的x坐标) / Π * 180;
	}

	else if (对象.对象重心的x坐标 < this->自身坐标和朝向.玩家的x坐标 && 对象.对象重心的y坐标 > this->自身坐标和朝向.玩家的y坐标)
	{
		//说明这是在第二象限
		对象.对象的重心朝向.水平朝向 =  180-atan2(对象.对象重心的y坐标 - this->自身坐标和朝向.玩家的y坐标, this->自身坐标和朝向.玩家的x坐标 - 对象.对象重心的x坐标) / Π * 180;
	}

	else if (对象.对象重心的x坐标 < this->自身坐标和朝向.玩家的x坐标 && 对象.对象重心的y坐标 < this->自身坐标和朝向.玩家的y坐标)
	{
		//说明这是在第三象限
		对象.对象的重心朝向.水平朝向 =180+atan2(this->自身坐标和朝向.玩家的y坐标 - 对象.对象重心的y坐标, this->自身坐标和朝向.玩家的x坐标 - 对象.对象重心的x坐标) / Π * 180;
	}

	else if (对象.对象重心的x坐标 > this->自身坐标和朝向.玩家的x坐标 && 对象.对象重心的y坐标 < this->自身坐标和朝向.玩家的y坐标)
	{
		//说明这是在第四象限
		对象.对象的重心朝向.水平朝向 = 360- atan2(this->自身坐标和朝向.玩家的y坐标 - 对象.对象重心的y坐标, 对象.对象重心的x坐标 - this->自身坐标和朝向.玩家的x坐标) / Π * 180;
	}


	float 水平面距离 = sqrt(pow(对象.对象重心的x坐标, 2) + pow(对象.对象重心的y坐标, 2));

	if (对象.对象重心的z坐标 > this->自身坐标和朝向.玩家的z坐标)
	{
		对象.对象的重心朝向.垂直朝向 = atan2(对象.对象重心的z坐标 - this->自身坐标和朝向.玩家的z坐标, 水平面距离) / Π * 180;
	}
	else
	{
		对象.对象的重心朝向.垂直朝向 = atan2(this->自身坐标和朝向.玩家的z坐标 - 对象.对象重心的z坐标, 水平面距离) / Π * 180;
	}

	if (this->自身坐标和朝向.玩家的朝向结构.水平朝向 - 对象.对象的重心朝向.水平朝向 < -180)
	{
		对象.对象重心的角度差.水平朝向 = this->自身坐标和朝向.玩家的朝向结构.水平朝向 - 对象.对象的重心朝向.水平朝向 + 360;
	}
	else if (this->自身坐标和朝向.玩家的朝向结构.水平朝向 - 对象.对象的重心朝向.水平朝向 > 180)
	{
		对象.对象重心的角度差.水平朝向 = this->自身坐标和朝向.玩家的朝向结构.水平朝向 - 对象.对象的重心朝向.水平朝向 - 360;
	}
	else
	{
		对象.对象重心的角度差.水平朝向 = this->自身坐标和朝向.玩家的朝向结构.水平朝向 - 对象.对象的重心朝向.水平朝向;
	}


	对象.对象重心的角度差.垂直朝向 = 0-this->自身坐标和朝向.玩家的朝向结构.垂直朝向 - 对象.对象的重心朝向.垂直朝向;

}

void 周围对象::刷新周围数据()
{
	//首先拿一下hw.dll的基地址
	unsigned int cstrike基地址 = (unsigned int)GetModuleHandleA("cstrike.exe");

	this->对象数量 = *(DWORD*)(*(DWORD*)(mp_dll基地址 + 0x16A470) + 0x58) + *(DWORD*)(*(DWORD*)(mp_dll基地址 + 0x16A470) + 0x54) ;

	//遍历获取玩家重心的xyz坐标
	// 
	// 引以为戒，因为重定向，这些基地址都是会变的
	//for (int i = 1; i < 32; i++) //这里从1开始是因为下标为1才是其他玩家的坐标
	//{
	//	this->对象列表[i-1].对象重心的x坐标 = *((float*)(0x5E3FEA8 + 0x250 * i + 0x18c));
	//	this->对象列表[i-1].对象重心的y坐标 = *((float*)(0x5E3FEA8 + 0x250 * i + 0x18c - 0x4));
	//	this->对象列表[i-1].对象重心的z坐标 = *((float*)(0x5E3FEA8 + 0x250 * i + 0x18c + 0x4));
	//}

	//for (int i = 1; i < 32; i++)
	//{
	//	this->对象列表[i - 1].阵营标志 = *(DWORD*)(0x53B6970 + 0x58 + 0x58 * i + 0x52);
	//	this->对象列表[i - 1].死亡标志 = *(DWORD*)(0x53B6970 + 0x58 + 0x58 * i + 0x44);
	//}
	DWORD 人物坐标结构体基地址 = 0x2F5A5C4;

	for (int i = 1; i < this->对象数量; i++) //这里从1开始是因为下标为1才是其他玩家的坐标
	{
		this->对象列表[i-1]->对象重心的y坐标 = *((float*)(人物坐标结构体基地址 + 0x24c * i + 0x18c));
		this->对象列表[i-1]->对象重心的x坐标 = *((float*)(人物坐标结构体基地址 + 0x24c * i + +0x188));
		this->对象列表[i-1]->对象重心的z坐标 = *((float*)(人物坐标结构体基地址 + 0x24c * i + 0x190));
	}

	DWORD 死亡标志位结构体基地址 = 0x1A25654;
	for (int i = 1; i < this->对象数量; i++)
	{
		if (*(DWORD*)(死亡标志位结构体基地址 + 0x68 + 0x68 * i + 0x8) == 0)//判定为敌方
		{
			this->对象列表[i - 1]->阵营标志 = 1;  //这里记录1代表地方
		}
		else
		{
			this->对象列表[i - 1]->阵营标志 = 0;  //这里记录1代表队友
		}
		
		this->对象列表[i - 1]->死亡标志 = *(DWORD*)(死亡标志位结构体基地址 + 0x68 + 0x68 * i );
	}

	for (int i = 1; i < this->对象数量; i++)
	{
		this->计算朝向(*对象列表[i - 1]);
	}
}


